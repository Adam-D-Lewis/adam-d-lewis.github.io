<!-- This layout is used in all pages. Making changes here will affect all pages. We recommend not to change anything here. --> <!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /><link rel="dns-prefetch" href="//fonts.googleapis.com" /><link rel="dns-prefetch" href="//google-analytics.com" /><link rel="dns-prefetch" href="//www.google-analytics.com" /><link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com" /><link rel="dns-prefetch" href="//ajax.googleapis.com" /><link rel="dns-prefetch" href="//fonts.gstatic.com" /><link rel="dns-prefetch" href="https://portfolio-ghw33nbcja.disqus.com/" /><title>Spatial Filtering at Scale with Dask and Spatialpandas | Adam Lewis Portfolio</title><meta name="generator" content="Jekyll v3.8.4" /><meta property="og:title" content="Spatial Filtering at Scale with Dask and Spatialpandas" /><meta name="author" content="Adam Lewis" /><meta property="og:locale" content="en_US" /><meta name="description" content="Photo Credit: NASA Earth Observatory images by Joshua Stevens, using Suomi NPP VIIRS data from Miguel Román, NASA’s Goddard Space Flight Center This article is cross-published on Quansight’s blog. Imagine having a dataset of over 50 TB of compressed geospatial point data stored in flat files, and you want to efficiently filter data in a few zip codes for further processing. You can’t even open a dataset that large on a single machine using tools like pandas, so what is the best way to accomplish the filtering? This is exactly the problem one of our clients recently faced. We addressed this challenge by spatially sorting the data, storing it in a partitionable binary file format, and parallelizing spatial filtering of the data all while using only open source tools within the PyData ecosystem on a commercial cloud platform. This white paper documents the potential solutions that we considered to address our client’s needs. Potential Approaches Our client was a small startup who needed to avoid large up-front infrastructure costs. This constrained our approaches to those possible via cloud providers like AWS, Azure, or GCP. We considered five potential approaches to meet the client’s needs, one of which employs a relational database, and four that use the PyData stack. Relational Database with Geospatial Extension Perhaps the first approach that comes to mind is the use of a relational database such as PostgreSQL and an extension like PostGIS which allows the use of spatial data types and queries on AWS Relational Database Service (RDS). The advantage of this approach is that it’s well established, but the strong disadvantage is cost. Databases hosted on AWS RDS have a variety of costs, but in this case, with such a large amount of data, database storage costs dominate. Using RDS requires using more expensive database storage rather than using S3 storage. Table 1 compares the costs of RDS Database Storage and S3 Storage at the time of writing. Database storage is 5x the cost of S3 storage making an RDS database approach unattractive. Approaches that allow the data to be accessed directly from S3 are more cost effective. This cost difference led us to consider the PyData stack. PyData Stack In this approach, building a solution using open-source libraries is more cost effective and transparent, but it’s more than that for us at Quansight. We are experts in the PyData open source tool stack. Many core contributors and creators of popular python open source packages have found a home at Quansight. We often see solutions that make significant use of open source tools, so naturally, this is where we focused the remainder of our development. Various open source python packages exist which could be combined to accomplish spatial sorting. We built several solutions and compared their performances below. Generally, each solution consists of five components, which are illustrated in Figure 2. Figure 2: Illustration of the general workflow for solutions based on the PyData stack approach. The five components are: Use a partitionable binary file format Spatially sort the dataset Create a global data index Parallelize data access and processing Spatially filter the relevant partitions We chose these components generally to reduce memory use and increase filtering speed. The first component, a partitionable binary file format, was useful because partitions allow for subsets of the data to be read. The second component was spatial sorting. It is the process of mapping 2-dimensional data to a single dimension such that points near each other in the single dimension are near each other in the original 2-dimensions, and then sorting the data by that single dimension. The third component, creating a global index of the partitions, allows for efficient lookup of the partitions which contain data in a particular region. After the data was sorted and indexed, it was saved in partitions, which could be opened individually instead of opening the entire dataset at once. With the data in that format, filtering (by zip code polygons in this paper) was much faster because we only needed to open the data partitions relevant to a specific region. The fourth component was parallelized access and processing of the relevant partitions. The relevant partitions of the dataset include points both within and outside the set of zip code polygons. The fifth component, another filtering step, was necessary to exclude data outside the zip code polygons. Spatial Sorting Spatial sorting deserves more explanation, and it can be performed using a variety of techniques. The idea is to map the original point data from latitude-longitude space to a 1-dimensional space such that points that are near each other in the 1-dimensional space are also near each other in latitude-longitude space. We can then sort the points based on the 1-dimensional space value. If that isn’t clear, the coming examples describing geohash and Hilbert curve spatial sorting should help. Several established systems could be used for spatially sorting the data including Geohash, Hilbert Curve, Uber H3, and Google S2 Geometry. We only considered the first two methods due to time constraints, but they are conceptually similar to the last two methods. Geohash Spatial Sort Example Using geohashes is the first way we considered spatially sorting the point data, but what is a geohash? In practical terms, a geohash is a string of characters which represents a rectangular region in latitude-longitude space. In Figure 3, geohash “9” represents the area contained in the red rectangle. Smaller and smaller subregions can be defined within the larger geohash by adding more characters. You can see that the geohash “9q” represents the region in the light blue rectangle which is contained within geohash “9”. You can continue adding characters to the geohash to define an arbitrarily small subregion. Figure 3: Background: Select one-character geohash regions plotted over a world map. Inset: All two-character geohashes starting with “9” as the first character plotted over a map. To spatially sort the data with geohashes, we mapped each point to its four character geohash, and then sorted the geohashes lexicographically. This results in the 2D latitude-longitude space being mapped to a 1D geohash space (string of characters) which can be sorted. The power of this method depended on the fact that points near each other in geohash space are also near each other in latitude-longitude space. Hilbert Curve Spatial Sort Example Instead of using geohashes, the point data could be spatially sorted via a Hilbert curve. In Figure 4, the Hilbert curve (red), is a continuous curve beginning in the bottom left, and ending in the bottom right which fills the 2D latitude-longitude space. If we snap our point data, to the nearest part of the Hilbert curve, we can define each point by the distance it lies along the Hilbert curve. We can then sort the data by the 1D Hilbert curve distance. After doing so, we’ve mapped our 2D latitude-longitude data to a 1D Hilbert curve distance dimension, and points which are near each other on the Hilbert curve are also near each other in latitude-longitude space. Figure 4: Image of 2D points plotted over a Hilbert curve in a latitude-longitude coordinate system. The red curvy line is the Hilbert curve inside the box. The points are arbitrary examples showing where they might lie relative to the curve. Tech stacks used in PyData solutions Now that the components of the general approach have been explained, let’s get into the specific packages implemented in the four solutions we tested. We conducted performance tests on the following stacks (Table 2) to help determine the best solution for our client. Table 2: Packages used in each Spatial Filtering Solution Parquet was used in all four potential solutions as the binary file format allowing partitioning of the data for subsequently accessing only relevant data partitions. For spatial sorting, solutions using both geohashes via Python-Geohash and the Hilbert curve via Spatialpandas were considered. Dask was used to build a global index of the data in the geohash sorted solutions, while Spatialpandas built the global index of the data in the Hilbert curve solution. Dask is used to read the data in parallel in all cases. Additionally, Dask is used to map the spatial filtering function across each of the data partitions in all cases. The spatial filtering function, a spatial join (explained below), was part of GeoPandas in the first 2 cases, and part of Spatialpandas in the last case. In the Sorted Geohash No Sjoin case, no final spatial filtering was performed, resulting in lower accuracy solution than the other cases. The spatial filtering function used in the last step was a spatial join. A spatial join is like a regular database join, except the keys being joined are geometric objects and the relationships between them can include geometric relationships (e.g. Join by points within a polygon). Different spatial join methods are implemented in GeoPandas and Spatialpandas. Benchmark In order to compare the various solutions, we established a benchmark against which to compare the solution performances in terms of runtime. The task is to filter a large amount of point data by various randomly selected US zip code polygons. We performed the task five times for each solution, each time increasing the number of zip code polygons. The dataset and machine specification details are given below. Our work can be freely downloaded and reproduced from it’s repository: https://github.com/Quansight/scipy2020_spatial_algorithms_at_scale. Each benchmarking test follows these steps: Preprocess data (if necessary) one time Calculate geohash or Hilbert curve Spatially sort data Save data in partitions Filter data for each query Select points from dataset that are within 1, 10, 100, 1000, 10000 random zip code polygons distributed around the contiguous US Dataset We used a dataset from OpenStreetMap (OSM), which originally consisted of 2.9 billion latitude-longitude point pairs. We removed data outside the contiguous US, leaving 114 million rows of point data in a 3.2 GB uncompressed CSV file. We then converted the data to a parquet file format. The data is available at https://planet.openstreetmap.org/gps/simple-gps-points-120604.csv.xz. The polygons are randomly selected US zip code polygons available from the US Census at https://www2.census.gov/geo/tiger/TIGER2019/ZCTA5/tl_2019_us_zcta510.zip. Machine Specifications Although a cloud cluster was used in production, the benchmark results presented here were performed on a workstation. The specs are included below: Processor: AMD Ryzen Threadripper 2970WX 24-Core Processor RAM: 64 GB For this comparison Dask Workers were limited to: 4 Workers 2 Threads per Worker 3 GB RAM per Worker Note that the final computation brings the filtered data into the main process potentially using more RAM than an individual worker has. Benchmark Results Unsorted Case As a baseline, we timed an unsorted case first. In this case, preprocessing and sorting of the data was not necessary. We simply opened up every partition of the data, and used GeoPandas to spatially join each partition of points with the set of zip code polygons. We spatially joined the partitions in parallel with Dask. The results are in Table 3. Each row contains the results of filtering the 114 million initial points by a different number of zip code polygons. Because this baseline does not require preprocessing, the Geohash and sort times are each 0 seconds. The query times were all above 40 minutes, and increased with increasing numbers of zip code polygons. The workers didn’t have enough memory to filter by 1000 or 10,000 zip code polygons. Sorted Geohash with Sjoin Case The next case used python-geohash to create geohashes for each point in our OSM dataset. Remember that this means each point in our dataset was labeled with a string of characters representing its location. Then, Dask was used to sort and index the data by the geohash labels. The geohash calculation and sorting times are one-time costs for a given dataset of points. The remaining steps must be performed each time a query is made, and are explained with the help of Figure 6 below. Figure 6: Illustration showing the spatial features involved in querying data in the sorted geohash case. In Figure 6, there is a bright red region representing a zip code area. The light blue and dark blue points are the subset of the points from our OSM dataset that lie within the pink geohashes (two, side-by-side) which intersect the zip code area. Our goal was to efficiently return the light blue points, those that intersect the zip code area. This was accomplished by opening only the data in the geohashes (partitions) intersecting the zip code polygon (light and dark blue points) using the global index of our spatially sorted data, and then applying spatial filtering to leave only the light blue points. In terms of our PyData stack, we first find the geohash polygons which intersect the zip code with Polygon-geohasher. Then we open our dataset with Dask. Dask uses its global index to open the partitions of our dataset corresponding to the geohash polygons (dark blue points). Then we used GeoPandas to perform a spatial join between the zip code polygon and the geohash points to exclude points outside of the zip code polygon and keep the points of interest (light blue points). The benchmark results are below. The one-time costs alone (30 min) are less than the single query time (~40 min) in the unsorted case (above), and this case was able to filter the data in the 1000 zip code polygon task. It’s important to note that the numbers of filtered data points are identical to the unsorted case, giving us confidence that we selected the same points. Sorted Geohash No Sjoin Case As the number of zip code polygons grows, the last spatial join step takes longer and longer. For some applications, the last spatial join step may not be necessary. The lower accuracy of returning all points that are near the zip code polygons, rather than only those within the zip code polygons reduces the query time significantly. In Figure 6, this solution would return all the light and dark blue points within the geohashes intersecting the zip code rather than just those light blue points within the zip code. This solution is not adequate in all cases, but the reduced query time may be worth it in some use cases. For example, this solution may be adequate when the uncertainty of the point data is greater than the size of the geohashes. The results of leaving off the last spatial join step are below. In this case, the query times are much lower, especially when the number of zip code polygons is higher, but the number of result points is also much larger, indicative of the lower filtering precision produced by excluding the last spatial join step. Spatialpandas Case The last case used a new package called Spatialpandas. Spatialpandas spatially sorts the data using the Hilbert curve. The results of using Spatialpandas are below. It wasn’t possible to separate the preprocessing time from the spatial sort time in this case, so they are included together in the sort time column. * Geohash time and sort time are combined because they could not be determined separately with Spatialpandas. This case was much faster than the other cases. Additionally, this was the only case that could filter the data by the 10,000 polygon set with full accuracy. This is because the Spatialpandas spatial join requires less memory than the GeoPandas spatial join method. Benchmark Result Comparison We’ve looked at the results individually, but the following plots compare the performances of the potential solutions. The first plot below shows the query times vs the number of zip code polygons by which the data was being filtered. Query times don’t include the one time costs like calculating geohashes, the Hilbert curve, or sorting the data. As shown in Figure 7, the query time for the unsorted case (red) took the longest at over 40 minutes, and this case was not able to process the two largest batches of zip code polygons. The query time for the sorted geohash without spatial join (yellow) was the fastest for 100 or more polygons, but remember that it wasn’t as accurate as the other solutions. The fastest query time for an accurate solution is the Spatialpandas case (green). Figure 7: Comparison of filtering time for each batch of zip code polygons. The dashed line indicates the case in which a spatial join was not used and the results are typically less accurate. Having looked at query times, now let’s look at the one-time preprocessing times shown in Figure 8. No preprocessing was necessary for the unsorted case, so the preprocessing time was 0 minutes. The two sorted geohash cases had the same preprocessing steps and are identical as a result. In the sorted geohash cases, the geohash calculation took 27 minutes, and the sorting took 3 minutes. By contrast, in the Spatialpandas case the preprocessing and sorting steps took just over 1 minute. Figure 8: Preprocessing times for the Sorted Geohash and Spatialpandas solutions. For Spatialpandas, the sort time includes the preprocessing time. Figure 9 shows the extrapolated total time (preprocessing + query time) vs the number of queries when filtering the data by 1, 100, and 10,000 polygons in each query. Query times are extrapolated under the assumption of linear scaling of queries based on the results of the single query time. Figure 9: Extrapolated total time vs number of queries using 1 polygon (left), 100 polygons (middle), and 10,000 polygons (right) in each query. Of the approaches with highest accuracy, the Spatialpandas solution is projected to be fastest in all situations. At times, the Sorted Geohash No Sjoin solution has lower total time than Spatialpandas, but this comes at the potentially high cost of accuracy. Additional Considerations Spatialpandas was the best overall solution explored here, and was what we ended up using for our client. Spatialpandas is an easy to install, pure python package. It makes heavy use of Numba for highly efficient spatial joins and bounding box queries. It’s also integrated nicely with Dask and the parquet file format. However, there are additional considerations to keep in mind. Spatialpandas is a young project with a small community at the moment. The documentation is limited compared with more established libraries, and it has low development activity for the moment. Spatialpandas is good at what it does, but it’s also limited in functionality. If you need Spatialpandas to do something similar, but slightly different from what is shown here, you may be forced to implement changes to the library yourself. Keep these considerations in mind if you’re thinking of using Spatialpandas in your application. Other Approaches Considered: AWS Athena, Omnisci and NVIDIA RAPIDS Other approaches were considered and experimented with. AWS Athena is a serverless interactive query service allowing users to query datasets residing in S3 via SQL queries. Though promising, at the time Athena had file size limitations that made it impractical for use and also did not obviate the need to sort and partition the data spatially to improve access times. The other main area considered was GPU acceleration. Two technologies were explored Omnisci and NVIDIA RAPIDS. These showed some promise but turned out to be too expensive to be practical. Omnisci has excellent GPU accelerated geospatial query performance but requires a fairly beefy GPU instance to run and requires that the data be imported into its internal format which also increases storage costs over S3. The NVIDIA RAPIDS suite has a new tool called CuSpatial but in practice, it is a very early prototype and is not usable in production. This work is heavily based on work originally presented at Scipy 2020, and can be viewed here." /><meta property="og:description" content="Photo Credit: NASA Earth Observatory images by Joshua Stevens, using Suomi NPP VIIRS data from Miguel Román, NASA’s Goddard Space Flight Center This article is cross-published on Quansight’s blog. Imagine having a dataset of over 50 TB of compressed geospatial point data stored in flat files, and you want to efficiently filter data in a few zip codes for further processing. You can’t even open a dataset that large on a single machine using tools like pandas, so what is the best way to accomplish the filtering? This is exactly the problem one of our clients recently faced. We addressed this challenge by spatially sorting the data, storing it in a partitionable binary file format, and parallelizing spatial filtering of the data all while using only open source tools within the PyData ecosystem on a commercial cloud platform. This white paper documents the potential solutions that we considered to address our client’s needs. Potential Approaches Our client was a small startup who needed to avoid large up-front infrastructure costs. This constrained our approaches to those possible via cloud providers like AWS, Azure, or GCP. We considered five potential approaches to meet the client’s needs, one of which employs a relational database, and four that use the PyData stack. Relational Database with Geospatial Extension Perhaps the first approach that comes to mind is the use of a relational database such as PostgreSQL and an extension like PostGIS which allows the use of spatial data types and queries on AWS Relational Database Service (RDS). The advantage of this approach is that it’s well established, but the strong disadvantage is cost. Databases hosted on AWS RDS have a variety of costs, but in this case, with such a large amount of data, database storage costs dominate. Using RDS requires using more expensive database storage rather than using S3 storage. Table 1 compares the costs of RDS Database Storage and S3 Storage at the time of writing. Database storage is 5x the cost of S3 storage making an RDS database approach unattractive. Approaches that allow the data to be accessed directly from S3 are more cost effective. This cost difference led us to consider the PyData stack. PyData Stack In this approach, building a solution using open-source libraries is more cost effective and transparent, but it’s more than that for us at Quansight. We are experts in the PyData open source tool stack. Many core contributors and creators of popular python open source packages have found a home at Quansight. We often see solutions that make significant use of open source tools, so naturally, this is where we focused the remainder of our development. Various open source python packages exist which could be combined to accomplish spatial sorting. We built several solutions and compared their performances below. Generally, each solution consists of five components, which are illustrated in Figure 2. Figure 2: Illustration of the general workflow for solutions based on the PyData stack approach. The five components are: Use a partitionable binary file format Spatially sort the dataset Create a global data index Parallelize data access and processing Spatially filter the relevant partitions We chose these components generally to reduce memory use and increase filtering speed. The first component, a partitionable binary file format, was useful because partitions allow for subsets of the data to be read. The second component was spatial sorting. It is the process of mapping 2-dimensional data to a single dimension such that points near each other in the single dimension are near each other in the original 2-dimensions, and then sorting the data by that single dimension. The third component, creating a global index of the partitions, allows for efficient lookup of the partitions which contain data in a particular region. After the data was sorted and indexed, it was saved in partitions, which could be opened individually instead of opening the entire dataset at once. With the data in that format, filtering (by zip code polygons in this paper) was much faster because we only needed to open the data partitions relevant to a specific region. The fourth component was parallelized access and processing of the relevant partitions. The relevant partitions of the dataset include points both within and outside the set of zip code polygons. The fifth component, another filtering step, was necessary to exclude data outside the zip code polygons. Spatial Sorting Spatial sorting deserves more explanation, and it can be performed using a variety of techniques. The idea is to map the original point data from latitude-longitude space to a 1-dimensional space such that points that are near each other in the 1-dimensional space are also near each other in latitude-longitude space. We can then sort the points based on the 1-dimensional space value. If that isn’t clear, the coming examples describing geohash and Hilbert curve spatial sorting should help. Several established systems could be used for spatially sorting the data including Geohash, Hilbert Curve, Uber H3, and Google S2 Geometry. We only considered the first two methods due to time constraints, but they are conceptually similar to the last two methods. Geohash Spatial Sort Example Using geohashes is the first way we considered spatially sorting the point data, but what is a geohash? In practical terms, a geohash is a string of characters which represents a rectangular region in latitude-longitude space. In Figure 3, geohash “9” represents the area contained in the red rectangle. Smaller and smaller subregions can be defined within the larger geohash by adding more characters. You can see that the geohash “9q” represents the region in the light blue rectangle which is contained within geohash “9”. You can continue adding characters to the geohash to define an arbitrarily small subregion. Figure 3: Background: Select one-character geohash regions plotted over a world map. Inset: All two-character geohashes starting with “9” as the first character plotted over a map. To spatially sort the data with geohashes, we mapped each point to its four character geohash, and then sorted the geohashes lexicographically. This results in the 2D latitude-longitude space being mapped to a 1D geohash space (string of characters) which can be sorted. The power of this method depended on the fact that points near each other in geohash space are also near each other in latitude-longitude space. Hilbert Curve Spatial Sort Example Instead of using geohashes, the point data could be spatially sorted via a Hilbert curve. In Figure 4, the Hilbert curve (red), is a continuous curve beginning in the bottom left, and ending in the bottom right which fills the 2D latitude-longitude space. If we snap our point data, to the nearest part of the Hilbert curve, we can define each point by the distance it lies along the Hilbert curve. We can then sort the data by the 1D Hilbert curve distance. After doing so, we’ve mapped our 2D latitude-longitude data to a 1D Hilbert curve distance dimension, and points which are near each other on the Hilbert curve are also near each other in latitude-longitude space. Figure 4: Image of 2D points plotted over a Hilbert curve in a latitude-longitude coordinate system. The red curvy line is the Hilbert curve inside the box. The points are arbitrary examples showing where they might lie relative to the curve. Tech stacks used in PyData solutions Now that the components of the general approach have been explained, let’s get into the specific packages implemented in the four solutions we tested. We conducted performance tests on the following stacks (Table 2) to help determine the best solution for our client. Table 2: Packages used in each Spatial Filtering Solution Parquet was used in all four potential solutions as the binary file format allowing partitioning of the data for subsequently accessing only relevant data partitions. For spatial sorting, solutions using both geohashes via Python-Geohash and the Hilbert curve via Spatialpandas were considered. Dask was used to build a global index of the data in the geohash sorted solutions, while Spatialpandas built the global index of the data in the Hilbert curve solution. Dask is used to read the data in parallel in all cases. Additionally, Dask is used to map the spatial filtering function across each of the data partitions in all cases. The spatial filtering function, a spatial join (explained below), was part of GeoPandas in the first 2 cases, and part of Spatialpandas in the last case. In the Sorted Geohash No Sjoin case, no final spatial filtering was performed, resulting in lower accuracy solution than the other cases. The spatial filtering function used in the last step was a spatial join. A spatial join is like a regular database join, except the keys being joined are geometric objects and the relationships between them can include geometric relationships (e.g. Join by points within a polygon). Different spatial join methods are implemented in GeoPandas and Spatialpandas. Benchmark In order to compare the various solutions, we established a benchmark against which to compare the solution performances in terms of runtime. The task is to filter a large amount of point data by various randomly selected US zip code polygons. We performed the task five times for each solution, each time increasing the number of zip code polygons. The dataset and machine specification details are given below. Our work can be freely downloaded and reproduced from it’s repository: https://github.com/Quansight/scipy2020_spatial_algorithms_at_scale. Each benchmarking test follows these steps: Preprocess data (if necessary) one time Calculate geohash or Hilbert curve Spatially sort data Save data in partitions Filter data for each query Select points from dataset that are within 1, 10, 100, 1000, 10000 random zip code polygons distributed around the contiguous US Dataset We used a dataset from OpenStreetMap (OSM), which originally consisted of 2.9 billion latitude-longitude point pairs. We removed data outside the contiguous US, leaving 114 million rows of point data in a 3.2 GB uncompressed CSV file. We then converted the data to a parquet file format. The data is available at https://planet.openstreetmap.org/gps/simple-gps-points-120604.csv.xz. The polygons are randomly selected US zip code polygons available from the US Census at https://www2.census.gov/geo/tiger/TIGER2019/ZCTA5/tl_2019_us_zcta510.zip. Machine Specifications Although a cloud cluster was used in production, the benchmark results presented here were performed on a workstation. The specs are included below: Processor: AMD Ryzen Threadripper 2970WX 24-Core Processor RAM: 64 GB For this comparison Dask Workers were limited to: 4 Workers 2 Threads per Worker 3 GB RAM per Worker Note that the final computation brings the filtered data into the main process potentially using more RAM than an individual worker has. Benchmark Results Unsorted Case As a baseline, we timed an unsorted case first. In this case, preprocessing and sorting of the data was not necessary. We simply opened up every partition of the data, and used GeoPandas to spatially join each partition of points with the set of zip code polygons. We spatially joined the partitions in parallel with Dask. The results are in Table 3. Each row contains the results of filtering the 114 million initial points by a different number of zip code polygons. Because this baseline does not require preprocessing, the Geohash and sort times are each 0 seconds. The query times were all above 40 minutes, and increased with increasing numbers of zip code polygons. The workers didn’t have enough memory to filter by 1000 or 10,000 zip code polygons. Sorted Geohash with Sjoin Case The next case used python-geohash to create geohashes for each point in our OSM dataset. Remember that this means each point in our dataset was labeled with a string of characters representing its location. Then, Dask was used to sort and index the data by the geohash labels. The geohash calculation and sorting times are one-time costs for a given dataset of points. The remaining steps must be performed each time a query is made, and are explained with the help of Figure 6 below. Figure 6: Illustration showing the spatial features involved in querying data in the sorted geohash case. In Figure 6, there is a bright red region representing a zip code area. The light blue and dark blue points are the subset of the points from our OSM dataset that lie within the pink geohashes (two, side-by-side) which intersect the zip code area. Our goal was to efficiently return the light blue points, those that intersect the zip code area. This was accomplished by opening only the data in the geohashes (partitions) intersecting the zip code polygon (light and dark blue points) using the global index of our spatially sorted data, and then applying spatial filtering to leave only the light blue points. In terms of our PyData stack, we first find the geohash polygons which intersect the zip code with Polygon-geohasher. Then we open our dataset with Dask. Dask uses its global index to open the partitions of our dataset corresponding to the geohash polygons (dark blue points). Then we used GeoPandas to perform a spatial join between the zip code polygon and the geohash points to exclude points outside of the zip code polygon and keep the points of interest (light blue points). The benchmark results are below. The one-time costs alone (30 min) are less than the single query time (~40 min) in the unsorted case (above), and this case was able to filter the data in the 1000 zip code polygon task. It’s important to note that the numbers of filtered data points are identical to the unsorted case, giving us confidence that we selected the same points. Sorted Geohash No Sjoin Case As the number of zip code polygons grows, the last spatial join step takes longer and longer. For some applications, the last spatial join step may not be necessary. The lower accuracy of returning all points that are near the zip code polygons, rather than only those within the zip code polygons reduces the query time significantly. In Figure 6, this solution would return all the light and dark blue points within the geohashes intersecting the zip code rather than just those light blue points within the zip code. This solution is not adequate in all cases, but the reduced query time may be worth it in some use cases. For example, this solution may be adequate when the uncertainty of the point data is greater than the size of the geohashes. The results of leaving off the last spatial join step are below. In this case, the query times are much lower, especially when the number of zip code polygons is higher, but the number of result points is also much larger, indicative of the lower filtering precision produced by excluding the last spatial join step. Spatialpandas Case The last case used a new package called Spatialpandas. Spatialpandas spatially sorts the data using the Hilbert curve. The results of using Spatialpandas are below. It wasn’t possible to separate the preprocessing time from the spatial sort time in this case, so they are included together in the sort time column. * Geohash time and sort time are combined because they could not be determined separately with Spatialpandas. This case was much faster than the other cases. Additionally, this was the only case that could filter the data by the 10,000 polygon set with full accuracy. This is because the Spatialpandas spatial join requires less memory than the GeoPandas spatial join method. Benchmark Result Comparison We’ve looked at the results individually, but the following plots compare the performances of the potential solutions. The first plot below shows the query times vs the number of zip code polygons by which the data was being filtered. Query times don’t include the one time costs like calculating geohashes, the Hilbert curve, or sorting the data. As shown in Figure 7, the query time for the unsorted case (red) took the longest at over 40 minutes, and this case was not able to process the two largest batches of zip code polygons. The query time for the sorted geohash without spatial join (yellow) was the fastest for 100 or more polygons, but remember that it wasn’t as accurate as the other solutions. The fastest query time for an accurate solution is the Spatialpandas case (green). Figure 7: Comparison of filtering time for each batch of zip code polygons. The dashed line indicates the case in which a spatial join was not used and the results are typically less accurate. Having looked at query times, now let’s look at the one-time preprocessing times shown in Figure 8. No preprocessing was necessary for the unsorted case, so the preprocessing time was 0 minutes. The two sorted geohash cases had the same preprocessing steps and are identical as a result. In the sorted geohash cases, the geohash calculation took 27 minutes, and the sorting took 3 minutes. By contrast, in the Spatialpandas case the preprocessing and sorting steps took just over 1 minute. Figure 8: Preprocessing times for the Sorted Geohash and Spatialpandas solutions. For Spatialpandas, the sort time includes the preprocessing time. Figure 9 shows the extrapolated total time (preprocessing + query time) vs the number of queries when filtering the data by 1, 100, and 10,000 polygons in each query. Query times are extrapolated under the assumption of linear scaling of queries based on the results of the single query time. Figure 9: Extrapolated total time vs number of queries using 1 polygon (left), 100 polygons (middle), and 10,000 polygons (right) in each query. Of the approaches with highest accuracy, the Spatialpandas solution is projected to be fastest in all situations. At times, the Sorted Geohash No Sjoin solution has lower total time than Spatialpandas, but this comes at the potentially high cost of accuracy. Additional Considerations Spatialpandas was the best overall solution explored here, and was what we ended up using for our client. Spatialpandas is an easy to install, pure python package. It makes heavy use of Numba for highly efficient spatial joins and bounding box queries. It’s also integrated nicely with Dask and the parquet file format. However, there are additional considerations to keep in mind. Spatialpandas is a young project with a small community at the moment. The documentation is limited compared with more established libraries, and it has low development activity for the moment. Spatialpandas is good at what it does, but it’s also limited in functionality. If you need Spatialpandas to do something similar, but slightly different from what is shown here, you may be forced to implement changes to the library yourself. Keep these considerations in mind if you’re thinking of using Spatialpandas in your application. Other Approaches Considered: AWS Athena, Omnisci and NVIDIA RAPIDS Other approaches were considered and experimented with. AWS Athena is a serverless interactive query service allowing users to query datasets residing in S3 via SQL queries. Though promising, at the time Athena had file size limitations that made it impractical for use and also did not obviate the need to sort and partition the data spatially to improve access times. The other main area considered was GPU acceleration. Two technologies were explored Omnisci and NVIDIA RAPIDS. These showed some promise but turned out to be too expensive to be practical. Omnisci has excellent GPU accelerated geospatial query performance but requires a fairly beefy GPU instance to run and requires that the data be imported into its internal format which also increases storage costs over S3. The NVIDIA RAPIDS suite has a new tool called CuSpatial but in practice, it is a very early prototype and is not usable in production. This work is heavily based on work originally presented at Scipy 2020, and can be viewed here." /><meta property="og:site_name" content="Adam Lewis Portfolio" /><meta property="og:image" content="/assets/images/spatial_filter_post/us_at_night.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-14T00:00:00+00:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="/assets/images/spatial_filter_post/us_at_night.jpg" /><meta property="twitter:title" content="Spatial Filtering at Scale with Dask and Spatialpandas" /><script type="application/ld+json"> {"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/spatial-filtering/"},"url":"/blog/spatial-filtering/","image":"/assets/images/spatial_filter_post/us_at_night.jpg","author":{"@type":"Person","name":"Adam Lewis"},"headline":"Spatial Filtering at Scale with Dask and Spatialpandas","dateModified":"2020-10-14T00:00:00+00:00","datePublished":"2020-10-14T00:00:00+00:00","description":"Photo Credit: NASA Earth Observatory images by Joshua Stevens, using Suomi NPP VIIRS data from Miguel Román, NASA’s Goddard Space Flight Center This article is cross-published on Quansight’s blog. Imagine having a dataset of over 50 TB of compressed geospatial point data stored in flat files, and you want to efficiently filter data in a few zip codes for further processing. You can’t even open a dataset that large on a single machine using tools like pandas, so what is the best way to accomplish the filtering? This is exactly the problem one of our clients recently faced. We addressed this challenge by spatially sorting the data, storing it in a partitionable binary file format, and parallelizing spatial filtering of the data all while using only open source tools within the PyData ecosystem on a commercial cloud platform. This white paper documents the potential solutions that we considered to address our client’s needs. Potential Approaches Our client was a small startup who needed to avoid large up-front infrastructure costs. This constrained our approaches to those possible via cloud providers like AWS, Azure, or GCP. We considered five potential approaches to meet the client’s needs, one of which employs a relational database, and four that use the PyData stack. Relational Database with Geospatial Extension Perhaps the first approach that comes to mind is the use of a relational database such as PostgreSQL and an extension like PostGIS which allows the use of spatial data types and queries on AWS Relational Database Service (RDS). The advantage of this approach is that it’s well established, but the strong disadvantage is cost. Databases hosted on AWS RDS have a variety of costs, but in this case, with such a large amount of data, database storage costs dominate. Using RDS requires using more expensive database storage rather than using S3 storage. Table 1 compares the costs of RDS Database Storage and S3 Storage at the time of writing. Database storage is 5x the cost of S3 storage making an RDS database approach unattractive. Approaches that allow the data to be accessed directly from S3 are more cost effective. This cost difference led us to consider the PyData stack. PyData Stack In this approach, building a solution using open-source libraries is more cost effective and transparent, but it’s more than that for us at Quansight. We are experts in the PyData open source tool stack. Many core contributors and creators of popular python open source packages have found a home at Quansight. We often see solutions that make significant use of open source tools, so naturally, this is where we focused the remainder of our development. Various open source python packages exist which could be combined to accomplish spatial sorting. We built several solutions and compared their performances below. Generally, each solution consists of five components, which are illustrated in Figure 2. Figure 2: Illustration of the general workflow for solutions based on the PyData stack approach. The five components are: Use a partitionable binary file format Spatially sort the dataset Create a global data index Parallelize data access and processing Spatially filter the relevant partitions We chose these components generally to reduce memory use and increase filtering speed. The first component, a partitionable binary file format, was useful because partitions allow for subsets of the data to be read. The second component was spatial sorting. It is the process of mapping 2-dimensional data to a single dimension such that points near each other in the single dimension are near each other in the original 2-dimensions, and then sorting the data by that single dimension. The third component, creating a global index of the partitions, allows for efficient lookup of the partitions which contain data in a particular region. After the data was sorted and indexed, it was saved in partitions, which could be opened individually instead of opening the entire dataset at once. With the data in that format, filtering (by zip code polygons in this paper) was much faster because we only needed to open the data partitions relevant to a specific region. The fourth component was parallelized access and processing of the relevant partitions. The relevant partitions of the dataset include points both within and outside the set of zip code polygons. The fifth component, another filtering step, was necessary to exclude data outside the zip code polygons. Spatial Sorting Spatial sorting deserves more explanation, and it can be performed using a variety of techniques. The idea is to map the original point data from latitude-longitude space to a 1-dimensional space such that points that are near each other in the 1-dimensional space are also near each other in latitude-longitude space. We can then sort the points based on the 1-dimensional space value. If that isn’t clear, the coming examples describing geohash and Hilbert curve spatial sorting should help. Several established systems could be used for spatially sorting the data including Geohash, Hilbert Curve, Uber H3, and Google S2 Geometry. We only considered the first two methods due to time constraints, but they are conceptually similar to the last two methods. Geohash Spatial Sort Example Using geohashes is the first way we considered spatially sorting the point data, but what is a geohash? In practical terms, a geohash is a string of characters which represents a rectangular region in latitude-longitude space. In Figure 3, geohash “9” represents the area contained in the red rectangle. Smaller and smaller subregions can be defined within the larger geohash by adding more characters. You can see that the geohash “9q” represents the region in the light blue rectangle which is contained within geohash “9”. You can continue adding characters to the geohash to define an arbitrarily small subregion. Figure 3: Background: Select one-character geohash regions plotted over a world map. Inset: All two-character geohashes starting with “9” as the first character plotted over a map. To spatially sort the data with geohashes, we mapped each point to its four character geohash, and then sorted the geohashes lexicographically. This results in the 2D latitude-longitude space being mapped to a 1D geohash space (string of characters) which can be sorted. The power of this method depended on the fact that points near each other in geohash space are also near each other in latitude-longitude space. Hilbert Curve Spatial Sort Example Instead of using geohashes, the point data could be spatially sorted via a Hilbert curve. In Figure 4, the Hilbert curve (red), is a continuous curve beginning in the bottom left, and ending in the bottom right which fills the 2D latitude-longitude space. If we snap our point data, to the nearest part of the Hilbert curve, we can define each point by the distance it lies along the Hilbert curve. We can then sort the data by the 1D Hilbert curve distance. After doing so, we’ve mapped our 2D latitude-longitude data to a 1D Hilbert curve distance dimension, and points which are near each other on the Hilbert curve are also near each other in latitude-longitude space. Figure 4: Image of 2D points plotted over a Hilbert curve in a latitude-longitude coordinate system. The red curvy line is the Hilbert curve inside the box. The points are arbitrary examples showing where they might lie relative to the curve. Tech stacks used in PyData solutions Now that the components of the general approach have been explained, let’s get into the specific packages implemented in the four solutions we tested. We conducted performance tests on the following stacks (Table 2) to help determine the best solution for our client. Table 2: Packages used in each Spatial Filtering Solution Parquet was used in all four potential solutions as the binary file format allowing partitioning of the data for subsequently accessing only relevant data partitions. For spatial sorting, solutions using both geohashes via Python-Geohash and the Hilbert curve via Spatialpandas were considered. Dask was used to build a global index of the data in the geohash sorted solutions, while Spatialpandas built the global index of the data in the Hilbert curve solution. Dask is used to read the data in parallel in all cases. Additionally, Dask is used to map the spatial filtering function across each of the data partitions in all cases. The spatial filtering function, a spatial join (explained below), was part of GeoPandas in the first 2 cases, and part of Spatialpandas in the last case. In the Sorted Geohash No Sjoin case, no final spatial filtering was performed, resulting in lower accuracy solution than the other cases. The spatial filtering function used in the last step was a spatial join. A spatial join is like a regular database join, except the keys being joined are geometric objects and the relationships between them can include geometric relationships (e.g. Join by points within a polygon). Different spatial join methods are implemented in GeoPandas and Spatialpandas. Benchmark In order to compare the various solutions, we established a benchmark against which to compare the solution performances in terms of runtime. The task is to filter a large amount of point data by various randomly selected US zip code polygons. We performed the task five times for each solution, each time increasing the number of zip code polygons. The dataset and machine specification details are given below. Our work can be freely downloaded and reproduced from it’s repository: https://github.com/Quansight/scipy2020_spatial_algorithms_at_scale. Each benchmarking test follows these steps: Preprocess data (if necessary) one time Calculate geohash or Hilbert curve Spatially sort data Save data in partitions Filter data for each query Select points from dataset that are within 1, 10, 100, 1000, 10000 random zip code polygons distributed around the contiguous US Dataset We used a dataset from OpenStreetMap (OSM), which originally consisted of 2.9 billion latitude-longitude point pairs. We removed data outside the contiguous US, leaving 114 million rows of point data in a 3.2 GB uncompressed CSV file. We then converted the data to a parquet file format. The data is available at https://planet.openstreetmap.org/gps/simple-gps-points-120604.csv.xz. The polygons are randomly selected US zip code polygons available from the US Census at https://www2.census.gov/geo/tiger/TIGER2019/ZCTA5/tl_2019_us_zcta510.zip. Machine Specifications Although a cloud cluster was used in production, the benchmark results presented here were performed on a workstation. The specs are included below: Processor: AMD Ryzen Threadripper 2970WX 24-Core Processor RAM: 64 GB For this comparison Dask Workers were limited to: 4 Workers 2 Threads per Worker 3 GB RAM per Worker Note that the final computation brings the filtered data into the main process potentially using more RAM than an individual worker has. Benchmark Results Unsorted Case As a baseline, we timed an unsorted case first. In this case, preprocessing and sorting of the data was not necessary. We simply opened up every partition of the data, and used GeoPandas to spatially join each partition of points with the set of zip code polygons. We spatially joined the partitions in parallel with Dask. The results are in Table 3. Each row contains the results of filtering the 114 million initial points by a different number of zip code polygons. Because this baseline does not require preprocessing, the Geohash and sort times are each 0 seconds. The query times were all above 40 minutes, and increased with increasing numbers of zip code polygons. The workers didn’t have enough memory to filter by 1000 or 10,000 zip code polygons. Sorted Geohash with Sjoin Case The next case used python-geohash to create geohashes for each point in our OSM dataset. Remember that this means each point in our dataset was labeled with a string of characters representing its location. Then, Dask was used to sort and index the data by the geohash labels. The geohash calculation and sorting times are one-time costs for a given dataset of points. The remaining steps must be performed each time a query is made, and are explained with the help of Figure 6 below. Figure 6: Illustration showing the spatial features involved in querying data in the sorted geohash case. In Figure 6, there is a bright red region representing a zip code area. The light blue and dark blue points are the subset of the points from our OSM dataset that lie within the pink geohashes (two, side-by-side) which intersect the zip code area. Our goal was to efficiently return the light blue points, those that intersect the zip code area. This was accomplished by opening only the data in the geohashes (partitions) intersecting the zip code polygon (light and dark blue points) using the global index of our spatially sorted data, and then applying spatial filtering to leave only the light blue points. In terms of our PyData stack, we first find the geohash polygons which intersect the zip code with Polygon-geohasher. Then we open our dataset with Dask. Dask uses its global index to open the partitions of our dataset corresponding to the geohash polygons (dark blue points). Then we used GeoPandas to perform a spatial join between the zip code polygon and the geohash points to exclude points outside of the zip code polygon and keep the points of interest (light blue points). The benchmark results are below. The one-time costs alone (30 min) are less than the single query time (~40 min) in the unsorted case (above), and this case was able to filter the data in the 1000 zip code polygon task. It’s important to note that the numbers of filtered data points are identical to the unsorted case, giving us confidence that we selected the same points. Sorted Geohash No Sjoin Case As the number of zip code polygons grows, the last spatial join step takes longer and longer. For some applications, the last spatial join step may not be necessary. The lower accuracy of returning all points that are near the zip code polygons, rather than only those within the zip code polygons reduces the query time significantly. In Figure 6, this solution would return all the light and dark blue points within the geohashes intersecting the zip code rather than just those light blue points within the zip code. This solution is not adequate in all cases, but the reduced query time may be worth it in some use cases. For example, this solution may be adequate when the uncertainty of the point data is greater than the size of the geohashes. The results of leaving off the last spatial join step are below. In this case, the query times are much lower, especially when the number of zip code polygons is higher, but the number of result points is also much larger, indicative of the lower filtering precision produced by excluding the last spatial join step. Spatialpandas Case The last case used a new package called Spatialpandas. Spatialpandas spatially sorts the data using the Hilbert curve. The results of using Spatialpandas are below. It wasn’t possible to separate the preprocessing time from the spatial sort time in this case, so they are included together in the sort time column. * Geohash time and sort time are combined because they could not be determined separately with Spatialpandas. This case was much faster than the other cases. Additionally, this was the only case that could filter the data by the 10,000 polygon set with full accuracy. This is because the Spatialpandas spatial join requires less memory than the GeoPandas spatial join method. Benchmark Result Comparison We’ve looked at the results individually, but the following plots compare the performances of the potential solutions. The first plot below shows the query times vs the number of zip code polygons by which the data was being filtered. Query times don’t include the one time costs like calculating geohashes, the Hilbert curve, or sorting the data. As shown in Figure 7, the query time for the unsorted case (red) took the longest at over 40 minutes, and this case was not able to process the two largest batches of zip code polygons. The query time for the sorted geohash without spatial join (yellow) was the fastest for 100 or more polygons, but remember that it wasn’t as accurate as the other solutions. The fastest query time for an accurate solution is the Spatialpandas case (green). Figure 7: Comparison of filtering time for each batch of zip code polygons. The dashed line indicates the case in which a spatial join was not used and the results are typically less accurate. Having looked at query times, now let’s look at the one-time preprocessing times shown in Figure 8. No preprocessing was necessary for the unsorted case, so the preprocessing time was 0 minutes. The two sorted geohash cases had the same preprocessing steps and are identical as a result. In the sorted geohash cases, the geohash calculation took 27 minutes, and the sorting took 3 minutes. By contrast, in the Spatialpandas case the preprocessing and sorting steps took just over 1 minute. Figure 8: Preprocessing times for the Sorted Geohash and Spatialpandas solutions. For Spatialpandas, the sort time includes the preprocessing time. Figure 9 shows the extrapolated total time (preprocessing + query time) vs the number of queries when filtering the data by 1, 100, and 10,000 polygons in each query. Query times are extrapolated under the assumption of linear scaling of queries based on the results of the single query time. Figure 9: Extrapolated total time vs number of queries using 1 polygon (left), 100 polygons (middle), and 10,000 polygons (right) in each query. Of the approaches with highest accuracy, the Spatialpandas solution is projected to be fastest in all situations. At times, the Sorted Geohash No Sjoin solution has lower total time than Spatialpandas, but this comes at the potentially high cost of accuracy. Additional Considerations Spatialpandas was the best overall solution explored here, and was what we ended up using for our client. Spatialpandas is an easy to install, pure python package. It makes heavy use of Numba for highly efficient spatial joins and bounding box queries. It’s also integrated nicely with Dask and the parquet file format. However, there are additional considerations to keep in mind. Spatialpandas is a young project with a small community at the moment. The documentation is limited compared with more established libraries, and it has low development activity for the moment. Spatialpandas is good at what it does, but it’s also limited in functionality. If you need Spatialpandas to do something similar, but slightly different from what is shown here, you may be forced to implement changes to the library yourself. Keep these considerations in mind if you’re thinking of using Spatialpandas in your application. Other Approaches Considered: AWS Athena, Omnisci and NVIDIA RAPIDS Other approaches were considered and experimented with. AWS Athena is a serverless interactive query service allowing users to query datasets residing in S3 via SQL queries. Though promising, at the time Athena had file size limitations that made it impractical for use and also did not obviate the need to sort and partition the data spatially to improve access times. The other main area considered was GPU acceleration. Two technologies were explored Omnisci and NVIDIA RAPIDS. These showed some promise but turned out to be too expensive to be practical. Omnisci has excellent GPU accelerated geospatial query performance but requires a fairly beefy GPU instance to run and requires that the data be imported into its internal format which also increases storage costs over S3. The NVIDIA RAPIDS suite has a new tool called CuSpatial but in practice, it is a very early prototype and is not usable in production. This work is heavily based on work originally presented at Scipy 2020, and can be viewed here.","@context":"https://schema.org"}</script><link rel="stylesheet" href="/assets/css/main-default.css" /><link id="color-scheme" rel="stylesheet" href="/assets/css/main-default.css" /><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/apple-icon-60x60.png" /><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/apple-icon-114x114.png" /><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/apple-icon-152x152.png" /><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/android-icon-192x192.png" /><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" /><link rel="icon" href="/favicon.ico" type="image/x-icon" /><script src="https://cdn.jsdelivr.net/npm/ga-lite@1/dist/ga-lite.min.js" async></script><script> var galite = galite || {}; galite.UA = 'UA-142377027-2';</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script></head><body><div class="loader"><div class="lds-ring"><div></div><div></div><div></div><div></div></div></div><div class="wrapper"><div class="container-grid"><div class="sidebar"><div class="author-container shadow"><div class="author"><img src="/assets/images/author-image.jpg" width="100%" height="auto;" alt="Adam Lewis Portfolio" onclick="location.href='/'"></div><div class="about text-center"><h1 class="title"><a href="/">Adam Lewis</a></h1></div><div class="bio text-center"><p class="m0">Data Scientist | ML Engineer</p></div><hr class="dashed"><div class="social text-center"> <ul class="portfolio p0"> <li><a href="/projects/">Projects</a></li> <li><a href="/blog/">Articles</a></li> <li><a href="/contact/">Contact</a></li> </ul> <ul class="sm p0 m0a"> <li><a href="/"><i class="fa fa-home"></i></a></li> <li><a href="https://www.linkedin.com/in/adam-d-lewis/"><i class="fa fa-linkedin"></i></a></li> <li><a href="https://github.com/Adam-D-Lewis"><i class="fa fa-github"></i></a></li> </ul></div></div></div><div class="main"><div class="main-container shadow"><div class="title-space"> <h1>Spatial Filtering at Scale with Dask and Spatialpandas</h1><div class="input-group mb-3" data-aos="zoom-in"> <input type="text" class="form-control" id="search-input"><div class="input-group-append"> <span class="input-group-text"><i class="fa fa-search"></i></span></div></div></div><hr class="dashed"> <main> <ul class="breadcrumbs"> <li><a href="/">Home</a></li> <li><a href="/blog/">Blog</a></li> <li><a href="#">Spatial filtering</a></li> </ul><div class="meta" data-aos="fade-up"> <p> <small> <span> <i class="fa fa-calendar" aria-hidden="true"></i> 14 Oct 2020&nbsp; </span> <span> <i class="fa fa-user" aria-hidden="true"></i> Adam Lewis&nbsp; </span> <span> <i class="fa fa-clock-o" aria-hidden="true"></i> 18 mins read. </span> </small> </p></div><div class="featured-image" style="background-image: url(/assets/images/spatial_filter_post/us_at_night.jpg)" data-aos="zoom-in" ></div><div class="container"> <article> <ul class="toc"> <li><a href="#potential-approaches">Potential Approaches</a></li> <li><a href="#relational-database-with-geospatial-extension">Relational Database with Geospatial Extension</a></li> <li><a href="#pydata-stack">PyData Stack</a></li> <li><a href="#spatial-sorting">Spatial Sorting</a> <ul> <li><a href="#geohash-spatial-sort-example">Geohash Spatial Sort Example</a></li> <li><a href="#hilbert-curve-spatial-sort-example">Hilbert Curve Spatial Sort Example</a></li> </ul> </li> <li><a href="#tech-stacks-used-in-pydata-solutions">Tech stacks used in PyData solutions</a></li> <li><a href="#benchmark">Benchmark</a> <ul> <li><a href="#dataset">Dataset</a></li> <li><a href="#machine-specifications">Machine Specifications</a></li> </ul> </li> <li><a href="#benchmark-results">Benchmark Results</a> <ul> <li><a href="#unsorted-case">Unsorted Case</a></li> <li><a href="#sorted-geohash-with-sjoin-case">Sorted Geohash with Sjoin Case</a></li> <li><a href="#sorted-geohash-no-sjoin-case">Sorted Geohash No Sjoin Case</a></li> <li><a href="#spatialpandas-case">Spatialpandas Case</a></li> <li><a href="#benchmark-result-comparison">Benchmark Result Comparison</a></li> </ul> </li> <li><a href="#additional-considerations">Additional Considerations</a></li> <li><a href="#other-approaches-considered-aws-athena-omnisci-and-nvidia-rapids">Other Approaches Considered: AWS Athena, Omnisci and NVIDIA RAPIDS</a></li> </ul> <p><em>Photo Credit: NASA Earth Observatory images by Joshua Stevens, using Suomi NPP VIIRS data from Miguel Román, NASA’s Goddard Space Flight Center</em></p> <p><em>This article is cross-published on <a href="https://www.quansight.com/post/spatial-filtering-at-scale-with-dask-and-spatialpandas">Quansight’s blog</a>.</em></p> <p>Imagine having a dataset of over 50 TB of compressed geospatial point data stored in flat files, and you want to efficiently filter data in a few zip codes for further processing. You can’t even open a dataset that large on a single machine using tools like pandas, so what is the best way to accomplish the filtering? This is exactly the problem one of our clients recently faced.</p> <p>We addressed this challenge by spatially sorting the data, storing it in a partitionable binary file format, and parallelizing spatial filtering of the data all while using only open source tools within the PyData ecosystem on a commercial cloud platform. This white paper documents the potential solutions that we considered to address our client’s needs.</p> <h2 id="potential-approaches">Potential Approaches</h2> <p>Our client was a small startup who needed to avoid large up-front infrastructure costs. This constrained our approaches to those possible via cloud providers like AWS, Azure, or GCP. We considered five potential approaches to meet the client’s needs, one of which employs a relational database, and four that use the PyData stack.</p> <h2 id="relational-database-with-geospatial-extension">Relational Database with Geospatial Extension</h2> <p>Perhaps the first approach that comes to mind is the use of a relational database such as PostgreSQL and an extension like PostGIS which allows the use of spatial data types and queries on AWS Relational Database Service (RDS). The advantage of this approach is that it’s well established, but the strong disadvantage is cost.</p> <p><img src="/assets/images/spatial_filter_post/aws_rds_costs_table.jpg" alt="" /></p> <p>Databases hosted on AWS RDS have a variety of costs, but in this case, with such a large amount of data, database storage costs dominate. Using RDS requires using more expensive database storage rather than using S3 storage. Table 1 compares the costs of RDS Database Storage and S3 Storage at the time of writing.</p> <p>Database storage is 5x the cost of S3 storage making an RDS database approach unattractive. Approaches that allow the data to be accessed directly from S3 are more cost effective. This cost difference led us to consider the PyData stack.</p> <h2 id="pydata-stack">PyData Stack</h2> <p>In this approach, building a solution using open-source libraries is more cost effective and transparent, but it’s more than that for us at Quansight. We are experts in the PyData open source tool stack. Many core contributors and creators of popular python open source packages have found a home at Quansight. We often see solutions that make significant use of open source tools, so naturally, this is where we focused the remainder of our development.</p> <p>Various open source python packages exist which could be combined to accomplish spatial sorting. We built several solutions and compared their performances below. Generally, each solution consists of five components, which are illustrated in Figure 2.</p> <p><img src="/assets/images/spatial_filter_post/fig2.png" alt="" /> <em>Figure 2: Illustration of the general workflow for solutions based on the PyData stack approach.</em></p> <p>The five components are:</p> <ol> <li>Use a partitionable binary file format</li> <li>Spatially sort the dataset</li> <li>Create a global data index</li> <li>Parallelize data access and processing</li> <li>Spatially filter the relevant partitions</li> </ol> <p>We chose these components generally to reduce memory use and increase filtering speed. The first component, a partitionable binary file format, was useful because partitions allow for subsets of the data to be read. The second component was spatial sorting. It is the process of mapping 2-dimensional data to a single dimension such that points near each other in the single dimension are near each other in the original 2-dimensions, and then sorting the data by that single dimension. The third component, creating a global index of the partitions, allows for efficient lookup of the partitions which contain data in a particular region. After the data was sorted and indexed, it was saved in partitions, which could be opened individually instead of opening the entire dataset at once. With the data in that format, filtering (by zip code polygons in this paper) was much faster because we only needed to open the data partitions relevant to a specific region. The fourth component was parallelized access and processing of the relevant partitions. The relevant partitions of the dataset include points both within and outside the set of zip code polygons. The fifth component, another filtering step, was necessary to exclude data outside the zip code polygons.</p> <h2 id="spatial-sorting">Spatial Sorting</h2> <p>Spatial sorting deserves more explanation, and it can be performed using a variety of techniques. The idea is to map the original point data from latitude-longitude space to a 1-dimensional space such that points that are near each other in the 1-dimensional space are also near each other in latitude-longitude space. We can then sort the points based on the 1-dimensional space value. If that isn’t clear, the coming examples describing geohash and Hilbert curve spatial sorting should help.</p> <p>Several established systems could be used for spatially sorting the data including Geohash, Hilbert Curve, Uber H3, and Google S2 Geometry. We only considered the first two methods due to time constraints, but they are conceptually similar to the last two methods.</p> <h3 id="geohash-spatial-sort-example">Geohash Spatial Sort Example</h3> <p>Using geohashes is the first way we considered spatially sorting the point data, but what is a geohash? In practical terms, a geohash is a string of characters which represents a rectangular region in latitude-longitude space. In Figure 3, geohash “9” represents the area contained in the red rectangle. Smaller and smaller subregions can be defined within the larger geohash by adding more characters. You can see that the geohash “9q” represents the region in the light blue rectangle which is contained within geohash “9”. You can continue adding characters to the geohash to define an arbitrarily small subregion.</p> <p><img src="/assets/images/spatial_filter_post/geohash_with_inset.png" alt="" /> <em>Figure 3: Background: Select one-character geohash regions plotted over a world map. Inset: All two-character geohashes starting with “9” as the first character plotted over a map.</em></p> <p>To spatially sort the data with geohashes, we mapped each point to its four character geohash, and then sorted the geohashes lexicographically. This results in the 2D latitude-longitude space being mapped to a 1D geohash space (string of characters) which can be sorted. The power of this method depended on the fact that points near each other in geohash space are also near each other in latitude-longitude space.</p> <h3 id="hilbert-curve-spatial-sort-example">Hilbert Curve Spatial Sort Example</h3> <p>Instead of using geohashes, the point data could be spatially sorted via a Hilbert curve. In Figure 4, the Hilbert curve (red), is a continuous curve beginning in the bottom left, and ending in the bottom right which fills the 2D latitude-longitude space. If we snap our point data, to the nearest part of the Hilbert curve, we can define each point by the distance it lies along the Hilbert curve. We can then sort the data by the 1D Hilbert curve distance. After doing so, we’ve mapped our 2D latitude-longitude data to a 1D Hilbert curve distance dimension, and points which are near each other on the Hilbert curve are also near each other in latitude-longitude space.</p><div style="text-align: center"> <img src="/assets/images/spatial_filter_post/fig4.png" width="400" /></div><p><em>Figure 4: Image of 2D points plotted over a Hilbert curve in a latitude-longitude coordinate system. The red curvy line is the Hilbert curve inside the box. The points are arbitrary examples showing where they might lie relative to the curve.</em></p> <h2 id="tech-stacks-used-in-pydata-solutions">Tech stacks used in PyData solutions</h2> <p>Now that the components of the general approach have been explained, let’s get into the specific packages implemented in the four solutions we tested. We conducted performance tests on the following stacks (Table 2) to help determine the best solution for our client.</p> <p>Table 2: Packages used in each Spatial Filtering Solution <img src="/assets/images/spatial_filter_post/Tech_Stack_Table_Image.png" alt="" /></p> <p>Parquet was used in all four potential solutions as the binary file format allowing partitioning of the data for subsequently accessing only relevant data partitions. For spatial sorting, solutions using both geohashes via Python-Geohash and the Hilbert curve via Spatialpandas were considered. Dask was used to build a global index of the data in the geohash sorted solutions, while Spatialpandas built the global index of the data in the Hilbert curve solution. Dask is used to read the data in parallel in all cases. Additionally, Dask is used to map the spatial filtering function across each of the data partitions in all cases. The spatial filtering function, a spatial join (explained below), was part of GeoPandas in the first 2 cases, and part of Spatialpandas in the last case. In the Sorted Geohash No Sjoin case, no final spatial filtering was performed, resulting in lower accuracy solution than the other cases.</p> <p>The spatial filtering function used in the last step was a spatial join. A spatial join is like a regular database join, except the keys being joined are geometric objects and the relationships between them can include geometric relationships (e.g. Join by points within a polygon). Different spatial join methods are implemented in GeoPandas and Spatialpandas.</p> <h2 id="benchmark">Benchmark</h2> <p>In order to compare the various solutions, we established a benchmark against which to compare the solution performances in terms of runtime. The task is to filter a large amount of point data by various randomly selected US zip code polygons. We performed the task five times for each solution, each time increasing the number of zip code polygons. The dataset and machine specification details are given below. Our work can be freely downloaded and reproduced from it’s repository: <a href="https://github.com/Quansight/scipy2020_spatial_algorithms_at_scale">https://github.com/Quansight/scipy2020_spatial_algorithms_at_scale</a>.</p> <p>Each benchmarking test follows these steps:</p> <ul> <li>Preprocess data (if necessary) one time <ul> <li>Calculate geohash or Hilbert curve</li> <li>Spatially sort data</li> <li>Save data in partitions</li> </ul> </li> <li>Filter data for each query <ul> <li>Select points from dataset that are within 1, 10, 100, 1000, 10000 random zip code polygons distributed around the contiguous US</li> </ul> </li> </ul> <h3 id="dataset">Dataset</h3> <p>We used a dataset from OpenStreetMap (OSM), which originally consisted of 2.9 billion latitude-longitude point pairs. We removed data outside the contiguous US, leaving 114 million rows of point data in a 3.2 GB uncompressed CSV file. We then converted the data to a parquet file format. The data is available at <a href="https://planet.openstreetmap.org/gps/simple-gps-points-120604.csv.xz">https://planet.openstreetmap.org/gps/simple-gps-points-120604.csv.xz</a>. The polygons are randomly selected US zip code polygons available from the US Census at <a href="https://www2.census.gov/geo/tiger/TIGER2019/ZCTA5/tl_2019_us_zcta510.zip">https://www2.census.gov/geo/tiger/TIGER2019/ZCTA5/tl_2019_us_zcta510.zip</a>.</p> <h3 id="machine-specifications">Machine Specifications</h3> <p>Although a cloud cluster was used in production, the benchmark results presented here were performed on a workstation. The specs are included below:</p> <ul> <li>Processor: AMD Ryzen Threadripper 2970WX 24-Core Processor</li> <li>RAM: 64 GB</li> <li>For this comparison Dask Workers were limited to: <ul> <li>4 Workers</li> <li>2 Threads per Worker</li> <li>3 GB RAM per Worker</li> </ul> </li> </ul> <p>Note that the final computation brings the filtered data into the main process potentially using more RAM than an individual worker has.</p> <h2 id="benchmark-results">Benchmark Results</h2> <h3 id="unsorted-case">Unsorted Case</h3> <p>As a baseline, we timed an unsorted case first. In this case, preprocessing and sorting of the data was not necessary. We simply opened up every partition of the data, and used GeoPandas to spatially join each partition of points with the set of zip code polygons. We spatially joined the partitions in parallel with Dask. The results are in Table 3.</p> <p><img src="/assets/images/spatial_filter_post/table_3.jpg" alt="" /></p> <p>Each row contains the results of filtering the 114 million initial points by a different number of zip code polygons. Because this baseline does not require preprocessing, the Geohash and sort times are each 0 seconds. The query times were all above 40 minutes, and increased with increasing numbers of zip code polygons. The workers didn’t have enough memory to filter by 1000 or 10,000 zip code polygons.</p> <h3 id="sorted-geohash-with-sjoin-case">Sorted Geohash with Sjoin Case</h3> <p>The next case used python-geohash to create geohashes for each point in our OSM dataset. Remember that this means each point in our dataset was labeled with a string of characters representing its location. Then, Dask was used to sort and index the data by the geohash labels. The geohash calculation and sorting times are one-time costs for a given dataset of points. The remaining steps must be performed each time a query is made, and are explained with the help of Figure 6 below.</p> <p><img src="/assets/images/spatial_filter_post/fig6.jpg" alt="" /> <em>Figure 6: Illustration showing the spatial features involved in querying data in the sorted geohash case.</em></p> <p>In Figure 6, there is a bright red region representing a zip code area. The light blue and dark blue points are the subset of the points from our OSM dataset that lie within the pink geohashes (two, side-by-side) which intersect the zip code area. Our goal was to efficiently return the light blue points, those that intersect the zip code area. This was accomplished by opening only the data in the geohashes (partitions) intersecting the zip code polygon (light and dark blue points) using the global index of our spatially sorted data, and then applying spatial filtering to leave only the light blue points.</p> <p>In terms of our PyData stack, we first find the geohash polygons which intersect the zip code with Polygon-geohasher. Then we open our dataset with Dask. Dask uses its global index to open the partitions of our dataset corresponding to the geohash polygons (dark blue points). Then we used GeoPandas to perform a spatial join between the zip code polygon and the geohash points to exclude points outside of the zip code polygon and keep the points of interest (light blue points). The benchmark results are below.</p> <p><img src="/assets/images/spatial_filter_post/table4.jpg" alt="" /></p> <p>The one-time costs alone (30 min) are less than the single query time (~40 min) in the unsorted case (above), and this case was able to filter the data in the 1000 zip code polygon task. It’s important to note that the numbers of filtered data points are identical to the unsorted case, giving us confidence that we selected the same points.</p> <h3 id="sorted-geohash-no-sjoin-case">Sorted Geohash No Sjoin Case</h3> <p>As the number of zip code polygons grows, the last spatial join step takes longer and longer. For some applications, the last spatial join step may not be necessary. The lower accuracy of returning all points that are near the zip code polygons, rather than only those within the zip code polygons reduces the query time significantly. In Figure 6, this solution would return all the light and dark blue points within the geohashes intersecting the zip code rather than just those light blue points within the zip code. This solution is not adequate in all cases, but the reduced query time may be worth it in some use cases. For example, this solution may be adequate when the uncertainty of the point data is greater than the size of the geohashes. The results of leaving off the last spatial join step are below.</p> <p><img src="/assets/images/spatial_filter_post/table5.jpg" alt="" /></p> <p>In this case, the query times are much lower, especially when the number of zip code polygons is higher, but the number of result points is also much larger, indicative of the lower filtering precision produced by excluding the last spatial join step.</p> <h3 id="spatialpandas-case">Spatialpandas Case</h3> <p>The last case used a new package called Spatialpandas. Spatialpandas spatially sorts the data using the Hilbert curve. The results of using Spatialpandas are below. It wasn’t possible to separate the preprocessing time from the spatial sort time in this case, so they are included together in the sort time column.</p> <p><img src="/assets/images/spatial_filter_post/table6.jpg" alt="" /> <em>* Geohash time and sort time are combined because they could not be determined separately with Spatialpandas.</em></p> <p>This case was much faster than the other cases. Additionally, this was the only case that could filter the data by the 10,000 polygon set with full accuracy. This is because the Spatialpandas spatial join requires less memory than the GeoPandas spatial join method.</p> <h3 id="benchmark-result-comparison">Benchmark Result Comparison</h3> <p>We’ve looked at the results individually, but the following plots compare the performances of the potential solutions. The first plot below shows the query times vs the number of zip code polygons by which the data was being filtered. Query times don’t include the one time costs like calculating geohashes, the Hilbert curve, or sorting the data.</p> <p>As shown in Figure 7, the query time for the unsorted case (red) took the longest at over 40 minutes, and this case was not able to process the two largest batches of zip code polygons. The query time for the sorted geohash without spatial join (yellow) was the fastest for 100 or more polygons, but remember that it wasn’t as accurate as the other solutions. The fastest query time for an accurate solution is the Spatialpandas case (green).</p> <p><img src="/assets/images/spatial_filter_post/fig7.jpg" alt="" /> <em>Figure 7: Comparison of filtering time for each batch of zip code polygons. The dashed line indicates the case in which a spatial join was not used and the results are typically less accurate.</em></p> <p>Having looked at query times, now let’s look at the one-time preprocessing times shown in Figure 8. No preprocessing was necessary for the unsorted case, so the preprocessing time was 0 minutes. The two sorted geohash cases had the same preprocessing steps and are identical as a result. In the sorted geohash cases, the geohash calculation took 27 minutes, and the sorting took 3 minutes. By contrast, in the Spatialpandas case the preprocessing and sorting steps took just over 1 minute.</p> <p><img src="/assets/images/spatial_filter_post/fig8.jpg" alt="" /></p> <p><em>Figure 8: Preprocessing times for the Sorted Geohash and Spatialpandas solutions. For Spatialpandas, the sort time includes the preprocessing time.</em></p> <p>Figure 9 shows the extrapolated total time (preprocessing + query time) vs the number of queries when filtering the data by 1, 100, and 10,000 polygons in each query. Query times are extrapolated under the assumption of linear scaling of queries based on the results of the single query time.</p> <p><img src="/assets/images/spatial_filter_post/fig9.jpg" alt="" /> <em>Figure 9: Extrapolated total time vs number of queries using 1 polygon (left), 100 polygons (middle), and 10,000 polygons (right) in each query.</em></p> <p>Of the approaches with highest accuracy, the Spatialpandas solution is projected to be fastest in all situations. At times, the Sorted Geohash No Sjoin solution has lower total time than Spatialpandas, but this comes at the potentially high cost of accuracy.</p> <h2 id="additional-considerations">Additional Considerations</h2> <p>Spatialpandas was the best overall solution explored here, and was what we ended up using for our client. Spatialpandas is an easy to install, pure python package. It makes heavy use of Numba for highly efficient spatial joins and bounding box queries. It’s also integrated nicely with Dask and the parquet file format.</p> <p>However, there are additional considerations to keep in mind. Spatialpandas is a young project with a small community at the moment. The documentation is limited compared with more established libraries, and it has low development activity for the moment. Spatialpandas is good at what it does, but it’s also limited in functionality. If you need Spatialpandas to do something similar, but slightly different from what is shown here, you may be forced to implement changes to the library yourself. Keep these considerations in mind if you’re thinking of using Spatialpandas in your application.</p> <h2 id="other-approaches-considered-aws-athena-omnisci-and-nvidia-rapids">Other Approaches Considered: AWS Athena, Omnisci and NVIDIA RAPIDS</h2> <p>Other approaches were considered and experimented with. AWS Athena is a serverless interactive query service allowing users to query datasets residing in S3 via SQL queries. Though promising, at the time Athena had file size limitations that made it impractical for use and also did not obviate the need to sort and partition the data spatially to improve access times. The other main area considered was GPU acceleration. Two technologies were explored Omnisci and NVIDIA RAPIDS. These showed some promise but turned out to be too expensive to be practical. Omnisci has excellent GPU accelerated geospatial query performance but requires a fairly beefy GPU instance to run and requires that the data be imported into its internal format which also increases storage costs over S3. The NVIDIA RAPIDS suite has a new tool called CuSpatial but in practice, it is a very early prototype and is not usable in production.</p> <p><em>This work is heavily based on work originally presented at Scipy 2020, and can be viewed <a href="https://www.youtube.com/watch?v=czesBVUoXvk" title="Spatial Algoirthms at Scale with Spatialpandas">here</a>.</em></p> </article></div><hr class="dashed" /><div class="container"><div class="row" data-aos="fade-up"><div class="col-md-12"><div class="share-box"> Share with others: <a class="f nostyle" href="https://www.facebook.com/sharer/sharer.php?u=/blog/spatial-filtering/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-facebook-official fa"></i ></a> <a class="t nostyle" href="https://twitter.com/intent/tweet?text=&url=/blog/spatial-filtering/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-twitter fa"></i ></a> <a class="g nostyle" href="https://plus.google.com/share?url=/blog/spatial-filtering/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-google-plus fa"></i ></a> <a class="r nostyle" href="http://www.reddit.com/submit?url=/blog/spatial-filtering/" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-reddit fa"></i ></a> <a class="l nostyle" href="https://www.linkedin.com/shareArticle?mini=true&url=/blog/spatial-filtering/&title=&summary=&source=webjeda" onclick="window.open(this.href, 'mywin', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" ><i class="fa fa-linkedin fa"></i ></a> <a class="e nostyle" href="mailto:?subject=&amp;body=Check&amp;out&amp;this&amp;site&amp;/blog/spatial-filtering/" ><i class="fa fa-envelope fa"></i ></a></div></div></div><div class="row"><div class="col-md-12"> <p class="categories" data-aos="fade-up"> <span><a href="/categories/#spatialpandas">Spatialpandas</a></span> <span><a href="/categories/#spatial-filtering">Spatial filtering</a></span> <span><a href="/categories/#dask">Dask</a></span> <span><a href="/categories/#pandas">Pandas</a></span> </p></div></div><div id="disqus_thread" data-aos="fade-up"></div><script defer> (function() { var d = document, s = d.createElement("script"); s.src = "//portfolio-ghw33nbcja.disqus.com/embed.js"; s.setAttribute("data-timestamp", +new Date()); (d.head || d.body).appendChild(s); })();</script><noscript>Please enable JavaScript to view the comments</noscript><div class="recent" data-aos="fade-up"><div class=""> <h3>Recent Articles</h3></div><div class="recent-grid"><div class="items" data-aos="fade-up"> <a class="nostyle item" href="/blog/getting-started-in-os/"><div class="cards"><div class="image" style="background-image: url(/assets/images/computer.jpg)" ></div><p class="title"><small>Getting Started in Open Source: Lessons learned from a first-time open source contributor</small></p></div></a></div></div></div></div></main><div id="search-container"></div><hr class="dashed"><footer data-aos="fade-up"><div class="text-right"> <p class="copy"> <i class="fa fa-at"></i> 2020 <a class="rev" href="">Adam Lewis</a> </p></div></footer></div></div></div></div><script src="/assets/js/jQuery.min.js"></script><script> $(document).ready(function () { $(".loader").hide(); });</script><script> (function () { var css = document.createElement('link'); css.href = '/assets/font-awesome-4.7.0/css/font-awesome.min.css'; css.rel = 'stylesheet'; css.type = 'text/css'; document.getElementsByTagName('head')[0].appendChild(css); })();</script><noscript><link rel="stylesheet" href="/assets/font-awesome-4.7.0/css/font-awesome.min.css"> </noscript><script> $("#search-input").keyup(function () { $("main").hide(); $("search-container").show(); if (!$('#search-input').val()) { $("main").show(); $("search-container").hide(); } });</script><script src="/assets/js/jekyll-search.min.js" type="text/javascript"></script><script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-container'), searchResultTemplate: '<a class="nostyle" href="{url}"><div class="blog borders cards"><div class="image" style="background-image: url({image});"></div><div class="content"><h3 class="title">{title}</h3><p class="description">{description}</p></div></div></a>', noResultsText: 'No results found', json: '/search.json' })</script><script> (function () { var css = document.createElement('link'); css.href = 'https://unpkg.com/aos@2.3.1/dist/aos.css'; css.rel = 'stylesheet'; css.type = 'text/css'; document.getElementsByTagName('head')[0].appendChild(css); })();</script><noscript><link rel="stylesheet" href="/assets/animate-on-scroll/aos.min.css"> </noscript><script src="/assets/animate-on-scroll/aos.min.js"></script><script> AOS.init({ duration: 600, once: true, disable: 'mobile' });</script></body></html>